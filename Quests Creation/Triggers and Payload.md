# Triggers and Payload

Each trigger in the system generates a payload that is passed to actions and conditions blocks along with the the global payload. When defining a call to action/condition block in the flow nodes, the developer specifies how to map a param from the payload to a param passed to the block. 

This document:

- Lists the available triggers along with the payload generated by each of them
- Lists the global payload params
- Explains how the payload is mapped to actions/conditions blocks params
- Explains the usage of the special `result` param passed to each condition and action

## Triggers

### USER_MESSAGE

Triggered when the user sends a chat message to one of the bots.
This trigger must contain `params` with `person` key.
For examplec:

```yaml
trigger: 
  type: user_message
  params:
    person: head-of-rd
  flowNode:
    ...
```

Payload:

- `userMessageText`: the text user wrote to the bot

### GITHUB_PR_LIFECYCLE_STATUS

Triggered when the status of a PR user opened is changed

- `eventType:` the status of the PR. Equal to one of the following:
    - `github_pr_opened:` PR just opened by the user
    - `github_pr_workflow_complete_success:` All PR checks passed with success
    - `github_pr_workflow_complete_failure:` One of PR checks failed
    - `github_pr_merged:` User merged the PR
- `githubPrNumber:` PR number
- `githubRepository:` Name of the repository in which the PR was opened

### PING

Triggered when ping event happened in the user’s Anythink repo. No specific payload.

### CHAT_OPENED

Triggered when the user opens Snack. No specific payload

### LOCAL_PAGE_LOAD

Triggered when the user opens a page in Anythink frontend.

Payload:

- `path:` URL of the opened page

### HEROKU_RELEASE_CREATED

Triggered when new Heroku release is created. 

Payload:

- `eventType:` type of the event that caused new release. For example, when setting config var: `^Set (.*) config var`
- `eventData:` The full body sent by Heroku. See example here: [https://devcenter.heroku.com/articles/webhook-events#api-release](https://devcenter.heroku.com/articles/webhook-events#api-release).

### GITHUB_USER_CONNECTED

Triggered when the user accepts the invitation to his Github repo. No specific payload

### NEWRELIC_EVENT_RECEIVED

Triggered when an event received from user’s New Relic account.

## Global Payload

In addition to specific payload passed by each trigger, a global payload is always available:

- `user`: The Wilco user object. Contains the following fields (partial list):
    - `firstName`
    - `lastName`
    - `email`
    - `githubuser:` User’s Github user name
    - `repository:` User’s Github repo url
    - `repoName:` Name of user’s Github repo
    - `company`
    - `backendHerokuAppName:` name of the backend Heroku app
    - `frontendHerokuAppName:` name of the frontend Heroku app
    - `newrelic:` User’s New-Relic account information
        - `accountId`
        - `apiKey`
    - `frameworks:` The backend and frontend frameworks chosen by the user
        - `backend:` One of node/rails/pythob
        - `frontend:` Currently only react
        - `database:` One of mongodb/postgresql
    
    Usage example:
    
    ```yaml
    actionId: github_pr_approve
    params:
      person: head-of-rd
      message: Nailed it! Excellent job @**${user.githubuser}**! You can now merge the PR.
    ```
    
- `bots:` Info about the bots. A map from bot Id to bot details.
    
     Available Ids are
    
    - `devops`
    - `head-of-rd`
    
    information for each bot:
    
    - `displayName:` name of the bot. E.g, Ness or Navi
    
    Usage example:
    
    ```yaml
    actionId: bot_message
    params:
      person: devops
      messages:
      - text: Hey ${user.firstName},
        delay: 2000
      - text: I'm **${bots['devops'].displayName}**, the DevOps team leader.
        delay: 1500
      - text: "**${bots['head-of-rd'].displayName}** asked me to help you out. Just write
          here your *GitHub username* (without the \\`@\\`, so Messenger doesn’t freak
          out), and we'll add you as a contributor to the company's repository."
        delay: 3500
    ```
    
- `nextQuestUrl:` url for the next quest.
    
    Equal to: `${CONFIG.ENVIRONMENT.WILCO_APP_URL}/home`
    

## Mapping payload to block params

- All payload (trigger + global) params are passed as is to each block. This way no additional configuration in the YAML is required for trivial cases.
    
    A good example is Github blocks which usually require a pr number or repo name:
    
    ```jsx
    const isFileInPRContains = async ({
      user,
      githubPrNumber,
      fileName,
      regex,
    }) => {
      const file = await getAddedFile(user, githubPrNumber, [fileName]);
      return !!file?.patch?.match(RegExp(regex));
    };
    ```
    
    In this example,  `user` and `githubPrNumber` are available in the condition params without any further configuration. Calling the `github_is_file_contains` can be configured in the YAML files, for example, in the following way (only `regex` and `fileName` are defined):
    
    ```yaml
    if:
      conditions:
        - conditionId: github_is_file_contains
          params:
            regex: license_key
          paramsFramework:
            node:
              fileName: backend/newrelic.js
            rails:
              fileName: backend/config/newrelic.yml
            python:
              fileName: backend/newrelic.ini
      then:
        ...
    ```
    

- In many cases, it is required to map the payload param to the block param. Referencing payload params is done using `${<payload_param>}`. Two such cases can be:
    - The name of the block param is different from its name in the payload
        
        An example of such a case is checking if chat message matches some regex:
        
        ```yaml
        if:
          conditions:
          - conditionId: text_match_regex
            params:
              text: "${userMessageText}"
              regex: ".*localhost.*@"
          then:
        ```
        
        In this example, the param `userMessageText` is passed to the condition as `text`
        
    - It is required to pass the payload param after some manipulation or as part of a more complex string (or both). An example for such case:
        
        ```yaml
        do:
          - actionId: bot_message
            params:
              person: head-of-rd
              messages:
              - text: Ooohh, I didn’t expect you to do this so quickly! Even your username,
                  ${path.slice(2)}, brings back memories. Strangely enough, they’re
                  your memories, which I don’t know why I have.
                delay: 2000
        ```
        
        We embed `path` param from the payload to the text sent to `head-of-rd` bot. The param here is embedded after applying `slice(2)` on its value.
        

## Result param

In addition to the payload params, a `result` param is passed to all conditions and actions. Each block can decide if to use it or not. The `result` param is used to pass information from the block to the next blocks. 

- The result is unique for each block, and they are not shared. Meaning that a block can’t override or change the result objects of other blocks.
- The result will be stored only if `name` was set for the block. In that case, the result of a block named `some_name` will be stored in the global payload in `payload.outputs[some_name]`. If name is missing, the result won't be stored and won't be used.
    
    A more specific example:
    
    ```yaml
    conditions:
      - conditionId: heroku_check_backend_config_var
        name: new_relic_license_key_config
        params:
          key: NEW_RELIC_LICENSE_KEY
    then: ...
    ```
    
    In this example we call an action with id `heroku_check_backend_config_var` and give it a name,  `new_relic_license_key_config.` This condition check that a config var exists, and also sets its value on the result, if exists. 
    
    ```json
    {
    	"value": "config_var_val"
    }
    ```
    
    Then, the config var value can be used in next blocks. Foe example:
    
    ```yaml
    if:
      conditions:
        - conditionId: newrelic_license_key_valid
          params:
            licenseKey: '${outputs.new_relic_license_key_config.value}'
      then: ...
    ```
    
    The config var is used as input to the `newrelic_license_key_valid` condition which checks that the value is a valid New-Relic license key.
    

A default result is initialized for all conditions and actions.

- For actions, the result is initialized to:
    
    ```json
    {
    	"success": true
    	"error": null
    }
    ```
    

- For conditions, the result is initialized to:
    
    ```json
    {
    	"error": null
    }
    ```
    
    No need for `success` as conditions always return true/false and `success` is set according to the result. Meaning, `output.condition_name` will contain `success` as well.
